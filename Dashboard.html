<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEPA IoT Advanced Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
       
        .header {
            background: #ffffff;
            border: 1px solid #e0e6ed;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            text-align: center;
        }
       
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
       
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
       
        .control-panel {
            background: #ffffff;
            border: 1px solid #e0e6ed;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
       
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
       
        .form-group {
            display: flex;
            flex-direction: column;
        }
       
        label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
            font-size: 0.95em;
        }
       
        select, input, button {
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
       
        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
       
        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
       
        button:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
       
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }
       
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
       
        .card {
            background: #ffffff;
            border: 1px solid #e0e6ed;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: box-shadow 0.3s ease;
        }
       
        .card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
        }
       
        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
       
        .status {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid;
        }
       
        .status.loading {
            background: #e8f4ff;
            border-color: #3498db;
            color: #2980b9;
        }
       
        .status.success {
            background: #d4edda;
            border-color: #27ae60;
            color: #27ae60;
        }
       
        .status.error {
            background: #f8d7da;
            border-color: #e74c3c;
            color: #c0392b;
        }
       
        .status.warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
       
        .analysis-panel {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
       
        .analysis-panel.show {
            display: block;
        }
       
        .progress-container {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
       
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
            margin: 10px 0;
        }
       
        .progress-fill {
            height: 100%;
            background: #3498db;
            border-radius: 6px;
            transition: width 0.3s ease;
            width: 0%;
        }
       
        .device-info {
            background: #e8f5e8;
            border: 1px solid #27ae60;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 25px;
        }
       
        .device-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
       
        .detail-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
       
        .detail-label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
       
        .detail-value {
            color: #27ae60;
            font-weight: 500;
        }
       
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
        }
       
        .chart-container {
            position: relative;
            height: 350px;
            margin: 15px 0;
            background: white;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 15px;
        }
       
        .summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
       
        .metric-card {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #3498db;
            transition: transform 0.3s ease;
        }
       
        .metric-card:hover {
            transform: translateY(-2px);
        }
       
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
       
        .metric-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }
       
        .batch-info {
            background: #e8f4fd;
            border: 1px solid #3498db;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.9em;
        }
       
        .data-quality {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #17a2b8;
            border-radius: 8px;
        }
       
        .forecast-section {
            margin-top: 30px;
            background: #fff8dc;
            border: 1px solid #f39c12;
            border-radius: 8px;
            padding: 25px;
        }
       
        .insights-section {
            background: #f0f8ff;
            border: 1px solid #3498db;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
        }
       
        .insight-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #e74c3c;
            border: 1px solid #ddd;
        }
       
        .forecast-chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
            background: white;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 15px;
        }
       
        .forecast-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
       
        .method-result {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
       
        .method-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }
       
        .method-value {
            font-size: 1.3em;
            color: #3498db;
            font-weight: bold;
        }
       
        .method-confidence {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }
       
        .server-config {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }
       
        .server-config.show {
            display: block;
        }
       
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
           
            .form-grid {
                grid-template-columns: 1fr;
            }
           
            .charts-grid {
                grid-template-columns: 1fr;
            }
           
            .button-group {
                flex-direction: column;
            }
           
            .summary-metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }
       
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
       
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SEPA IoT Advanced Analytics Dashboard</h1>
            <p class="subtitle">SEPA API and local server data fetching with advanced analytics and forecasting</p>
        </div>
       
        <div class="control-panel">
            <h3>Device Selection & Data Collection</h3>
           
            <div class="form-grid">
                <div class="form-group">
                    <label for="dataSource">Data Source:</label>
                    <select id="dataSource">
                        <option value="api">SEPA API (Live Data)</option>
                        <option value="server">Local Server (FastAPI)</option>
                    </select>
                </div>
               
                <div class="form-group">
                    <label for="deviceType">Device Type:</label>
                    <select id="deviceType">
                        <option value="">Select device type...</option>
                        <option value="HydroRanger">HydroRanger (Water Level Monitoring)</option>
                        <option value="Echo">Echo (Ultrasonic Water Level)</option>
                        <option value="Droplet">Droplet (Weather Station)</option>
                        <option value="Hygro">Hygro (Soil Monitoring)</option>
                        <option value="Theta">Theta (Advanced Soil Sensors)</option>
                    </select>
                </div>
               
                <div class="form-group">
                    <label for="deviceSelect">Device:</label>
                    <select id="deviceSelect" disabled>
                        <option value="">Select device type first...</option>
                    </select>
                </div>
               
                <div class="form-group">
                    <label for="dataRange">Data Collection Period:</label>
                    <select id="dataRange">
                        <option value="7">Last 7 days</option>
                        <option value="30">Last 30 days (Recommended)</option>
                        <option value="60">Last 2 months</option>
                        <option value="90">Last 3 months</option>
                        <option value="180">Last 6 months</option>
                        <option value="365">Full year</option>
                    </select>
                </div>
            </div>
           
            <!-- Server Configuration -->
            <div class="server-config" id="serverConfig">
                <div class="form-group">
                    <label for="serverUrl">FastAPI Server URL:</label>
                    <input type="text" id="serverUrl" value="http://127.0.0.1:8000" placeholder="http://127.0.0.1:8000" />
                    <p style="font-size: 0.9em; color: #7f8c8d; margin-top: 5px;">
                        Make sure your FastAPI server is running locally
                    </p>
                </div>
                <button id="testConnection">Test Server Connection</button>
            </div>
           
            <div class="button-group">
                <button id="fetchBounds">Check Data Availability</button>
                <button id="fetchData" disabled>Collect Data</button>
            </div>
        </div>
       
        <!-- Analysis Panel - Only shown after data is collected -->
        <div class="analysis-panel" id="analysisPanel">
            <h3>Analysis Options</h3>
            <div class="form-grid">
                <div class="form-group">
                    <label for="analysisType">Analysis Focus:</label>
                    <select id="analysisType">
                        <option value="overview">General Overview</option>
                        <option value="trends">Trend Analysis</option>
                        <option value="anomalies">Anomaly Detection</option>
                        <option value="forecast">Forecasting Focus</option>
                    </select>
                </div>
            </div>
           
            <div class="button-group">
                <button id="analyzeData">Run Analysis</button>
                <button id="generateForecast" disabled>Generate 7-Day Forecast</button>
                <button id="exportData" disabled>Export Results</button>
            </div>
        </div>
       
        <div id="status"></div>
        <div id="progressContainer" class="progress-container"></div>
        <div id="deviceInfo"></div>
        <div id="dataAnalysis"></div>
        <div id="chartsSection"></div>
        <div id="insightsSection"></div>
        <div id="forecastSection"></div>
    </div>
    <script>
        // Device configurations with enhanced metadata
        const devices = [
            // HydroRanger devices
            {"DevName": "HYDRORANGER #0009", "DeviceEUI": "F863663062792909", "SiteName": "Falkland Burn and Arraty Burn conf at B936 Road Bridge", "EmptyDistance": "2780", "Lon": "-3.207358", "Lat": "56.260429", "type": "HydroRanger"},
            {"DevName": "HYDRORANGER #0016", "DeviceEUI": "F863663062798591", "SiteName": "River Eden at Strathmiglo STW", "EmptyDistance": "2710", "Lon": "-3.252223", "Lat": "56.277705", "type": "HydroRanger"},
            {"DevName": "HYDRORANGER #0007", "DeviceEUI": "F863663062793717", "SiteName": "Auchtermuchty Burn d/s confluence at Glassarts Cottage", "EmptyDistance": "2049", "Lon": "-3.241392", "Lat": "56.304858", "type": "HydroRanger"},
            {"DevName": "HYDRORANGER #0005", "DeviceEUI": "F863663062793469", "SiteName": "River Eden at Dunshalt road bridge", "EmptyDistance": "4463", "Lon": "-3.2133164", "Lat": "56.277972", "type": "HydroRanger"},
            {"DevName": "HYDRORANGER #0001", "DeviceEUI": "F863663062793626", "SiteName": "Barroway Burn at Demperston Farm", "EmptyDistance": "2236", "Lon": "-3.256403", "Lat": "56.284666", "type": "HydroRanger"},
           
            // Echo devices
            {"DevName": "ECHO #1", "DeviceEUI": "70B3D54990566062", "SiteName": "Greenford Burn @ Greenford Farm", "EmptyDistance": "2390", "Lon": "-2.7085165243598386", "Lat": "56.553277272221514", "type": "Echo"},
            {"DevName": "ECHO #5", "DeviceEUI": "70B3D54999389C9B", "SiteName": "Road Bridge 600m West of Carmyllie", "EmptyDistance": "1773", "Lon": "-2.741944", "Lat": "56.569722", "type": "Echo"},
            {"DevName": "ECHO #2", "DeviceEUI": "70B3D54991EB3BA5", "SiteName": "Crossden burn @ Greenford Farm", "EmptyDistance": "2522", "Lon": "-2.7087453156770502", "Lat": "56.55409349771759", "type": "Echo"},
            {"DevName": "ECHO #4", "DeviceEUI": "70B3D5499B3A9F32", "SiteName": "Black Burn @ Milton of Conon", "EmptyDistance": "1390", "Lon": "-2.7031439317435857", "Lat": "56.58248250313473", "type": "Echo"},
           
            // Droplet devices
            {"DevName": "Droplet #8", "DeviceEUI": "70B3D5499E6F40FA", "SiteName": "Greenford Burn @ Greenford Farm", "Lon": "-2.708528970397459", "Lat": "56.55332005184382", "type": "Droplet"},
            {"DevName": "Droplet #3", "DeviceEUI": "70B3D549970021CD", "SiteName": "Elliot Water @ Greystone", "Lon": "-2.771389", "Lat": "56.581111", "type": "Droplet"},
            {"DevName": "Droplet #7", "DeviceEUI": "70B3D54995431295", "SiteName": "Black Burn @ Milton of Conon", "Lon": "-2.7031439317435857", "Lat": "56.58248250313473", "type": "Droplet"},
           
            // Hygro devices
            {"DevName": "Hygro#00:92", "DeviceEUI": "70B3D51C20000092", "SiteName": "Black Burn @ Milton of Conon", "Lon": "-2.7031439317435857", "Lat": "56.58248250313473", "type": "Hygro"},
            {"DevName": "Hygro#00:89", "DeviceEUI": "70B3D51C20000089", "SiteName": "Elliot Water @ Greystone", "Lon": "-2.771389", "Lat": "56.581111", "type": "Hygro"},
            {"DevName": "Hygro#00:94", "DeviceEUI": "70B3D51C20000094", "SiteName": "Greenford Burn @ Greenford Farm", "Lon": "-2.7083295059945645", "Lat": "56.55340120969614", "type": "Hygro"},
           
            // Theta devices
            {"DevName": "THETA #0005", "DeviceEUI": "F861275077947444", "SiteName": "Lady Burn at Kilmaron school", "Lon": "-3.028327", "Lat": "56.322513", "type": "Theta"},
            {"DevName": "THETA #0004", "DeviceEUI": "F861275077961817", "SiteName": "Rankeilour Burn at rail bridge", "Lon": "-3.079126", "Lat": "56.286225", "type": "Theta"},
            {"DevName": "THETA #0003", "DeviceEUI": "F861275077962088", "SiteName": "Falkland Burn and Arraty Burn conf at B936 Road Bridge", "Lon": "-3.207358", "Lat": "56.260429", "type": "Theta"}
        ];
        // API endpoints
        const SEPA_BASE_BOUNDS = "https://a8p8m605b5.execute-api.eu-west-2.amazonaws.com/sepa_iot_device_date_bounds";
        const SEPA_BASE_FETCH = "https://oujshf1m2h.execute-api.eu-west-2.amazonaws.com/tekh_dataFetch";
        // Global state
        let currentDevice = null;
        let currentData = [];
        let charts = {};
        let isProcessing = false;
        let forecastChart = null;
        let serverDevices = []; // For FastAPI server devices
        // Device-specific field configurations
        const deviceConfigs = {
            HydroRanger: {
                primaryFields: ['levelAvg', 'levelMin', 'levelMax'],
                secondaryFields: ['airTemp', 'airHumid'],
                units: {
                    levelAvg: 'mm', levelMin: 'mm', levelMax: 'mm',
                    airTemp: '°C', airHumid: '%'
                },
                labels: {
                    levelAvg: 'Water Level (Average)', levelMin: 'Water Level (Minimum)',
                    levelMax: 'Water Level (Maximum)', airTemp: 'Air Temperature', airHumid: 'Air Humidity'
                },
                colors: {
                    levelAvg: '#3498db', levelMin: '#e74c3c', levelMax: '#f39c12',
                    airTemp: '#27ae60', airHumid: '#9b59b6'
                }
            },
            Echo: {
                primaryFields: ['waterLevel'],
                secondaryFields: ['airTemp', 'battVolt', 'waterTemp'],
                units: {
                    waterLevel: 'mm', airTemp: '°C', battVolt: 'V', waterTemp: '°C'
                },
                labels: {
                    waterLevel: 'Water Level', airTemp: 'Air Temperature',
                    battVolt: 'Battery Voltage', waterTemp: 'Water Temperature'
                },
                colors: {
                    waterLevel: '#3498db', airTemp: '#27ae60', battVolt: '#e74c3c', waterTemp: '#17a2b8'
                }
            },
            Droplet: {
                primaryFields: ['airTemp', 'airPress', 'airHumid'],
                secondaryFields: ['battVolt', 'rtcTemp', 'rainfall'],
                units: {
                    airTemp: '°C', airPress: 'mb', airHumid: '%',
                    battVolt: 'V', rtcTemp: '°C', rainfall: 'mm'
                },
                labels: {
                    airTemp: 'Air Temperature', airPress: 'Air Pressure', airHumid: 'Air Humidity',
                    battVolt: 'Battery Voltage', rtcTemp: 'RTC Temperature', rainfall: 'Rainfall'
                },
                colors: {
                    airTemp: '#e74c3c', airPress: '#3498db', airHumid: '#9b59b6',
                    battVolt: '#f39c12', rtcTemp: '#27ae60', rainfall: '#17a2b8'
                }
            },
            Hygro: {
                primaryFields: ['soilMoisture', 'soilTemp'],
                secondaryFields: ['soilEC', 'airTemp', 'airHumid', 'battVolt'],
                units: {
                    soilMoisture: '%', soilTemp: '°C', soilEC: 'dS/m',
                    airTemp: '°C', airHumid: '%', battVolt: 'V'
                },
                labels: {
                    soilMoisture: 'Soil Moisture', soilTemp: 'Soil Temperature', soilEC: 'Soil Conductivity',
                    airTemp: 'Air Temperature', airHumid: 'Air Humidity', battVolt: 'Battery Voltage'
                },
                colors: {
                    soilMoisture: '#27ae60', soilTemp: '#e74c3c', soilEC: '#f39c12',
                    airTemp: '#3498db', airHumid: '#9b59b6', battVolt: '#e67e22'
                }
            },
            Theta: {
                primaryFields: ['soilMoisture', 'soilTemp'],
                secondaryFields: ['soilEC'],
                units: {
                    soilMoisture: '%', soilTemp: '°C', soilEC: 'dS/m'
                },
                labels: {
                    soilMoisture: 'Soil Moisture', soilTemp: 'Soil Temperature', soilEC: 'Soil Conductivity'
                },
                colors: {
                    soilMoisture: '#27ae60', soilTemp: '#e74c3c', soilEC: '#f39c12'
                }
            }
        };
        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', async function() {
            setupEventListeners();
            showStatus('Select a data source and device to begin analytics', 'loading');
        });
        function setupEventListeners() {
            document.getElementById('dataSource').addEventListener('change', onDataSourceChange);
            document.getElementById('deviceType').addEventListener('change', onDeviceTypeChange);
            document.getElementById('deviceSelect').addEventListener('change', onDeviceChange);
            document.getElementById('fetchBounds').addEventListener('click', checkDataAvailability);
            document.getElementById('fetchData').addEventListener('click', fetchData);
            document.getElementById('analyzeData').addEventListener('click', analyzeCollectedData);
            document.getElementById('generateForecast').addEventListener('click', generateAdvancedForecast);
            document.getElementById('exportData').addEventListener('click', exportAnalysisResults);
            document.getElementById('analysisType').addEventListener('change', onAnalysisTypeChange);
            document.getElementById('testConnection').addEventListener('click', testServerConnection);
        }
        function onDataSourceChange() {
            const dataSource = document.getElementById('dataSource').value;
            const serverConfig = document.getElementById('serverConfig');
           
            // Hide server config by default
            serverConfig.classList.remove('show');
           
            // Show server config if server is selected
            if (dataSource === 'server') {
                serverConfig.classList.add('show');
                // Load devices from server if available
                loadServerDevices();
            }
           
            resetDashboard();
            // Re-populate device list based on source
            onDeviceTypeChange();
        }
        async function testServerConnection() {
            const serverUrl = document.getElementById('serverUrl').value.trim();
            if (!serverUrl) {
                showStatus('Please enter server URL', 'error');
                return;
            }
           
            showStatus('Testing server connection...', 'loading');
           
            try {
                const response = await fetch(`${serverUrl}/health`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const health = await response.json();
                showStatus(`Server connected successfully! Status: ${health.status}`, 'success');
               
                // Load available devices from server
                await loadServerDevices();
               
            } catch (error) {
                showStatus(`Server connection failed: ${error.message}`, 'error');
            }
        }
        async function loadServerDevices() {
            const serverUrl = document.getElementById('serverUrl').value.trim();
            if (!serverUrl) return;
           
            try {
                serverDevices = [];
                const deviceTypes = ['HydroRanger', 'Echo', 'Droplet', 'Hygro', 'Theta'];
               
                for (const deviceType of deviceTypes) {
                    try {
                        const response = await fetch(`${serverUrl}/devices/${deviceType}`);
                        if (response.ok) {
                            const devices = await response.json();
                            serverDevices.push(...devices);
                        }
                    } catch (error) {
                        console.warn(`Failed to load ${deviceType} devices:`, error);
                    }
                }
               
                console.log(`Loaded ${serverDevices.length} devices from server`);
                // Refresh device dropdown if a type is selected
                if (document.getElementById('deviceType').value) {
                    onDeviceTypeChange();
                }
               
            } catch (error) {
                console.error('Error loading server devices:', error);
            }
        }
        function onDeviceTypeChange() {
            const selectedType = document.getElementById('deviceType').value;
            const deviceSelect = document.getElementById('deviceSelect');
            const dataSource = document.getElementById('dataSource').value;
           
            deviceSelect.innerHTML = '<option value="">Select device...</option>';
           
            if (selectedType) {
                let availableDevices = [];
               
                if (dataSource === 'server') {
                    availableDevices = serverDevices.filter(d => d.type === selectedType);
                } else {
                    availableDevices = devices.filter(d => d.type === selectedType);
                }
               
                availableDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.DeviceEUI;
                    option.textContent = `${device.DevName} - ${device.SiteName}`;
                    option.dataset.device = JSON.stringify(device);
                    deviceSelect.appendChild(option);
                });
               
                deviceSelect.disabled = false;
                document.getElementById('fetchBounds').disabled = false;
            } else {
                deviceSelect.disabled = true;
                document.getElementById('fetchBounds').disabled = true;
            }
           
            resetDashboard();
        }
        function onDeviceChange() {
            const deviceSelect = document.getElementById('deviceSelect');
            if (deviceSelect.value) {
                currentDevice = JSON.parse(deviceSelect.options[deviceSelect.selectedIndex].dataset.device);
                showDeviceInfo(currentDevice);
                document.getElementById('fetchBounds').disabled = false;
            } else {
                currentDevice = null;
                resetDashboard();
            }
        }
        function onAnalysisTypeChange() {
            if (currentData.length > 0) {
                showStatus('Updating analysis focus...', 'loading');
                setTimeout(() => {
                    analyzeCollectedData();
                    showStatus('Analysis updated successfully', 'success');
                }, 100);
            }
        }
        function resetDashboard() {
            document.getElementById('deviceInfo').innerHTML = '';
            document.getElementById('dataAnalysis').innerHTML = '';
            document.getElementById('chartsSection').innerHTML = '';
            document.getElementById('insightsSection').innerHTML = '';
            document.getElementById('forecastSection').innerHTML = '';
            document.getElementById('analysisPanel').classList.remove('show');
            document.getElementById('fetchData').disabled = true;
            document.getElementById('analyzeData').disabled = true;
            document.getElementById('generateForecast').disabled = true;
            document.getElementById('exportData').disabled = true;
            currentData = [];
           
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            if (forecastChart) {
                forecastChart.destroy();
                forecastChart = null;
            }
        }
        async function checkDataAvailability() {
            if (!currentDevice) {
                showStatus('Please select a device first', 'error');
                return;
            }
           
            const dataSource = document.getElementById('dataSource').value;
           
            try {
                if (dataSource === 'server') {
                    await checkServerAvailability();
                } else {
                    await checkAPIAvailability();
                }
            } catch (error) {
                showStatus(`Error checking data availability: ${error.message}`, 'error');
            }
        }
        async function checkServerAvailability() {
            const serverUrl = document.getElementById('serverUrl').value.trim();
            if (!serverUrl) {
                showStatus('Please configure server URL first', 'error');
                return;
            }
           
            showStatus('Checking server data availability...', 'loading');
           
            try {
                const response = await fetch(`${serverUrl}/data-bounds/${currentDevice.type}/${currentDevice.DeviceEUI}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const bounds = await response.json();
                const startDate = new Date(bounds.startTS);
                const endDate = new Date(bounds.endTS);
                const recordCount = bounds.recordCount || 'Unknown';
               
                showStatus(`Server data: ${recordCount} records from ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`, 'success');
                document.getElementById('fetchData').disabled = false;
               
            } catch (error) {
                showStatus(`Server data check failed: ${error.message}`, 'error');
            }
        }
        async function checkAPIAvailability() {
            showStatus('Checking SEPA API data availability...', 'loading');
           
            try {
                const bounds = await getDeviceBounds(currentDevice);
                const startDate = new Date(bounds.startTS);
                const endDate = new Date(bounds.endTS);
                const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
               
                showStatus(`SEPA API: Data from ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()} (${totalDays} days)`, 'success');
                document.getElementById('fetchData').disabled = false;
               
            } catch (error) {
                showStatus(`SEPA API check failed: ${error.message}`, 'error');
            }
        }
        async function fetchData() {
            if (!currentDevice || isProcessing) return;
           
            const dataSource = document.getElementById('dataSource').value;
           
            try {
                if (dataSource === 'server') {
                    await fetchFromServer();
                } else {
                    await fetchFromAPI();
                }
            } catch (error) {
                showStatus(`Data fetch failed: ${error.message}`, 'error');
            }
        }
        async function fetchFromServer() {
            const serverUrl = document.getElementById('serverUrl').value.trim();
            if (!serverUrl) {
                showStatus('Please configure server URL first', 'error');
                return;
            }
           
            isProcessing = true;
            showStatus('Fetching data from local server...', 'loading');
            showProgress('Requesting data from server...', 20);
           
            try {
                const dataRange = parseInt(document.getElementById('dataRange').value);
                const endDate = new Date();
                const startDate = new Date(endDate.getTime() - (dataRange * 24 * 60 * 60 * 1000));
               
                const url = new URL(`${serverUrl}/data/${currentDevice.type}/${currentDevice.DeviceEUI}`);
                url.searchParams.append('start_date', startDate.toISOString().split('T')[0]);
                url.searchParams.append('end_date', endDate.toISOString().split('T')[0]);
                url.searchParams.append('limit', '10000');
               
                showProgress('Processing server response...', 60);
               
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
               
                const serverData = await response.json();
               
                if (!serverData.data || serverData.data.length === 0) {
                    showStatus('No data returned from server for the selected period', 'error');
                    return;
                }
               
                showProgress('Converting server data format...', 80);
               
                // Convert server data format to our internal format
                currentData = serverData.data.map(record => {
                    const converted = {
                        timestamp: record.timestamp,
                        deviceEUI: record.deviceEUI,
                        payload: record.payload || ''
                    };
                   
                    // Map field names from server response to our internal format
                    const fieldMappings = {
                        // HydroRanger
                        'levelAvg': 'water_level_avg',
                        'levelMin': 'water_level_min',
                        'levelMax': 'water_level_max',
                        // Echo
                        'waterLevel': 'water_level',
                        'battVolt': 'battery_volt',
                        'waterTemp': 'water_temp',
                        // Droplet
                        'airPress': 'air_pressure',
                        'rtcTemp': 'rtc_temp',
                        // Common
                        'airTemp': 'air_temp',
                        'airHumid': 'air_humidity',
                        'soilMoisture': 'soil_moisture',
                        'soilTemp': 'soil_temp',
                        'soilEC': 'soil_conductivity'
                    };
                   
                    // Copy all fields, converting names as needed
                    Object.keys(record).forEach(key => {
                        if (key !== 'timestamp' && key !== 'deviceEUI' && key !== 'payload') {
                            // Find the internal field name for this server field
                            const internalField = Object.keys(fieldMappings).find(internal =>
                                fieldMappings[internal] === key
                            );
                            if (internalField) {
                                converted[internalField] = record[key];
                            } else {
                                // Direct mapping for fields that don't need conversion
                                converted[key] = record[key];
                            }
                        }
                    });
                   
                    return converted;
                });
               
                showProgress('Server data loaded successfully!', 100);
                showStatus(`Successfully loaded ${currentData.length.toLocaleString()} records from server`, 'success');
               
                // Enable analysis
                document.getElementById('analysisPanel').classList.add('show');
                document.getElementById('analyzeData').disabled = false;
                document.getElementById('generateForecast').disabled = false;
                document.getElementById('exportData').disabled = false;
               
                displayDataSummary();
               
            } catch (error) {
                console.error('Server fetch error:', error);
                showStatus(`Server data fetch failed: ${error.message}`, 'error');
            } finally {
                isProcessing = false;
                hideProgress();
            }
        }
        async function fetchFromAPI() {
            isProcessing = true;
            const dataRange = parseInt(document.getElementById('dataRange').value);
           
            showStatus('Starting multi-batch data collection from SEPA API...', 'loading');
            showProgress('Initializing batch collection...', 0);
           
            try {
                const bounds = await getDeviceBounds(currentDevice);
                const endDate = new Date(bounds.endTS);
                const startDate = new Date(Math.max(
                    new Date(bounds.startTS).getTime(),
                    endDate.getTime() - (dataRange * 24 * 60 * 60 * 1000)
                ));
               
                const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                const batchCount = Math.ceil(totalDays / 14);
               
                showProgress(`Collecting ${totalDays} days of data in ${batchCount} batches...`, 5);
               
                const allData = await collectDataInBatches(currentDevice, startDate, endDate, batchCount);
               
                if (allData.length === 0) {
                    showStatus('No data collected. Device may not have data in the selected period.', 'error');
                    return;
                }
               
                currentData = allData;
                showProgress('SEPA API data collection complete!', 100);
                showStatus(`Successfully collected ${currentData.length} records from ${batchCount} batches`, 'success');
               
                document.getElementById('analysisPanel').classList.add('show');
                document.getElementById('analyzeData').disabled = false;
                document.getElementById('generateForecast').disabled = false;
                document.getElementById('exportData').disabled = false;
               
                displayDataSummary();
               
            } catch (error) {
                showStatus(`SEPA API data collection failed: ${error.message}`, 'error');
                console.error('Collection error:', error);
            } finally {
                isProcessing = false;
                hideProgress();
            }
        }
        async function collectDataInBatches(device, startDate, endDate, batchCount) {
            const allRecords = [];
            let currentDate = new Date(startDate);
           
            for (let batchNum = 1; batchNum <= batchCount; batchNum++) {
                if (currentDate >= endDate) break;
               
                try {
                    const progressPercent = (batchNum / batchCount) * 90;
                    showProgress(`Batch ${batchNum}/${batchCount}: Fetching from ${currentDate.toLocaleDateString()}...`, progressPercent);
                   
                    const batchData = await fetchDeviceData(device, currentDate.toISOString());
                   
                    if (batchData && batchData.length > 0) {
                        const parsedBatch = parseBatchData(batchData, device);
                        allRecords.push(...parsedBatch);
                       
                        const lastRecord = batchData[batchData.length - 1];
                        currentDate = new Date(new Date(lastRecord.TimeStamp).getTime() + 1000);
                    } else {
                        currentDate = new Date(currentDate.getTime() + (14 * 24 * 60 * 60 * 1000));
                    }
                   
                    await new Promise(resolve => setTimeout(resolve, 100));
                   
                } catch (error) {
                    console.warn(`Batch ${batchNum} failed:`, error);
                    currentDate = new Date(currentDate.getTime() + (14 * 24 * 60 * 60 * 1000));
                }
            }
           
            return allRecords.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        }
        function parseBatchData(rawData, device) {
            const parsed = [];
           
            for (const record of rawData) {
                try {
                    const parsedPayload = parsePayload(device.type, record.Payload, device.EmptyDistance);
                   
                    if (parsedPayload && Array.isArray(parsedPayload)) {
                        const parsedRecord = {
                            timestamp: record.TimeStamp,
                            deviceEUI: record.DevEUI,
                            payload: record.Payload
                        };
                       
                        if (device.type === 'HydroRanger') {
                            parsedRecord.sensors = parsedPayload[0];
                            parsedRecord.levelAvg = parsedPayload[1];
                            parsedRecord.levelMin = parsedPayload[2];
                            parsedRecord.levelMax = parsedPayload[3];
                            parsedRecord.airTemp = parsedPayload[4];
                            parsedRecord.airHumid = parsedPayload[5];
                        } else if (device.type === 'Echo') {
                            parsedRecord.waterLevel = parsedPayload[0];
                            parsedRecord.airTemp = parsedPayload[1];
                            parsedRecord.battVolt = parsedPayload[2];
                            parsedRecord.waterTemp = parsedPayload[3];
                            parsedRecord.status = parsedPayload[4];
                        } else if (device.type === 'Droplet') {
                            parsedRecord.airTemp = parsedPayload[0];
                            parsedRecord.airPress = parsedPayload[1];
                            parsedRecord.airHumid = parsedPayload[2];
                            parsedRecord.battVolt = parsedPayload[3];
                            parsedRecord.rtcTemp = parsedPayload[4];
                            parsedRecord.rainfall = parsedPayload[5];
                            parsedRecord.status = parsedPayload[6];
                        } else if (device.type === 'Hygro') {
                            parsedRecord.soilMoisture = parsedPayload[0];
                            parsedRecord.soilTemp = parsedPayload[1];
                            parsedRecord.soilEC = parsedPayload[2];
                            parsedRecord.airTemp = parsedPayload[3];
                            parsedRecord.airHumid = parsedPayload[4];
                            parsedRecord.battVolt = parsedPayload[5];
                            parsedRecord.status = parsedPayload[6];
                        } else if (device.type === 'Theta') {
                            parsedRecord.soilMoisture = parsedPayload[0];
                            parsedRecord.soilTemp = parsedPayload[1];
                            parsedRecord.soilEC = parsedPayload[2];
                        }
                       
                        parsed.push(parsedRecord);
                    }
                } catch (error) {
                    console.warn('Parse error for record:', error);
                }
            }
           
            return parsed;
        }
        async function analyzeCollectedData() {
            if (currentData.length === 0) return;
           
            const config = deviceConfigs[currentDevice.type];
            const analysisType = document.getElementById('analysisType').value;
           
            createDeviceSpecificCharts(config);
            generateDataInsights(analysisType);
        }
        function displayDataSummary() {
            const totalRecords = currentData.length;
            const timeSpan = getTimeSpan();
            const dataQuality = calculateDataQuality();
           
            const summaryHTML = `
                <div class="card">
                    <h3>Data Collection Summary</h3>
                    <div class="summary-metrics">
                        <div class="metric-card">
                            <div class="metric-value">${totalRecords.toLocaleString()}</div>
                            <div class="metric-label">Total Records</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${timeSpan.days}</div>
                            <div class="metric-label">Days Collected</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${Math.round(totalRecords / timeSpan.days)}</div>
                            <div class="metric-label">Avg Records/Day</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${dataQuality.toFixed(1)}%</div>
                            <div class="metric-label">Data Quality</div>
                        </div>
                    </div>
                   
                    <div class="batch-info">
                        <strong>Collection Details:</strong><br>
                        Period: ${new Date(currentData[0].timestamp).toLocaleDateString()} to ${new Date(currentData[currentData.length-1].timestamp).toLocaleDateString()}<br>
                        Device: ${currentDevice.DevName} (${currentDevice.type})<br>
                        Location: ${currentDevice.SiteName}<br>
                        Source: ${document.getElementById('dataSource').options[document.getElementById('dataSource').selectedIndex].text}
                    </div>
                </div>
            `;
           
            document.getElementById('dataAnalysis').innerHTML = summaryHTML;
        }
        function createDeviceSpecificCharts(config) {
            const chartsHTML = `
                <div class="card">
                    <h3>Device-Specific Analytics - ${currentDevice.type}</h3>
                    <div class="charts-grid" id="chartsGrid"></div>
                </div>
            `;
           
            document.getElementById('chartsSection').innerHTML = chartsHTML;
           
            const allFields = [...config.primaryFields, ...config.secondaryFields];
            allFields.forEach((field, index) => {
                createIndividualChart(field, config, `chart-${field}`);
            });
        }
        function createIndividualChart(field, config, chartId) {
            const fieldData = currentData
                .filter(d => d[field] !== null && d[field] !== undefined && !isNaN(d[field]))
                .map(d => ({
                    x: new Date(d.timestamp),
                    y: d[field]
                }));
           
            if (fieldData.length === 0) {
                console.warn(`No data available for field: ${field}`);
                return;
            }
           
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.innerHTML = `<canvas id="${chartId}"></canvas>`;
            document.getElementById('chartsGrid').appendChild(chartContainer);
           
            const ctx = document.getElementById(chartId).getContext('2d');
           
            const dataset = {
                label: `${config.labels[field]} (${config.units[field]})`,
                data: fieldData,
                borderColor: config.colors[field],
                backgroundColor: config.colors[field] + '20',
                fill: true,
                tension: 0.4,
                pointRadius: fieldData.length > 200 ? 1 : 2,
                pointHoverRadius: 5,
                borderWidth: 2
            };
           
            const values = fieldData.map(d => d.y);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            const latest = values[values.length - 1];
           
            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [dataset]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    hour: 'MMM dd HH:mm',
                                    day: 'MMM dd',
                                    week: 'MMM dd',
                                    month: 'MMM yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: `${config.labels[field]} (${config.units[field]})`
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${config.labels[field]}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        subtitle: {
                            display: true,
                            text: `Current: ${latest.toFixed(2)} | Avg: ${avg.toFixed(2)} | Range: ${min.toFixed(2)} - ${max.toFixed(2)} ${config.units[field]}`,
                            font: {
                                size: 12
                            },
                            color: '#666'
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'nearest',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return `${config.labels[field]}: ${context.parsed.y.toFixed(2)} ${config.units[field]}`;
                                },
                                afterLabel: function(context) {
                                    const timestamp = new Date(context.parsed.x);
                                    return `Time: ${timestamp.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        function generateDataInsights(analysisType) {
            const config = deviceConfigs[currentDevice.type];
            const insights = [];
           
            switch (analysisType) {
                case 'trends':
                    insights.push(...generateTrendInsights(config));
                    break;
                case 'anomalies':
                    insights.push(...generateAnomalyInsights(config));
                    break;
                case 'forecast':
                    insights.push(...generateForecastInsights(config));
                    break;
                default:
                    insights.push(...generateOverviewInsights(config));
            }
           
            displayInsights(insights);
        }
        function generateOverviewInsights(config) {
            const insights = [];
            const timeSpan = getTimeSpan();
            const dataSource = document.getElementById('dataSource').options[document.getElementById('dataSource').selectedIndex].text;
           
            insights.push(`Analyzed ${currentData.length.toLocaleString()} records over ${timeSpan.days} days from ${dataSource}`);
           
            if (currentDevice.type === 'HydroRanger' || currentDevice.type === 'Echo') {
                const levelField = currentDevice.type === 'HydroRanger' ? 'levelAvg' : 'waterLevel';
                const levels = currentData.map(d => d[levelField]).filter(l => l !== null && !isNaN(l));
                if (levels.length > 0) {
                    const avgLevel = levels.reduce((a, b) => a + b, 0) / levels.length;
                    const maxLevel = Math.max(...levels);
                    const minLevel = Math.min(...levels);
                    insights.push(`Water levels: Average ${avgLevel.toFixed(1)}mm, Range ${minLevel.toFixed(1)}-${maxLevel.toFixed(1)}mm`);
                }
            }
           
            if (currentDevice.type === 'Hygro' || currentDevice.type === 'Theta') {
                const moisture = currentData.map(d => d.soilMoisture).filter(m => m !== null && !isNaN(m));
                if (moisture.length > 0) {
                    const avgMoisture = moisture.reduce((a, b) => a + b, 0) / moisture.length;
                    insights.push(`Soil moisture average: ${avgMoisture.toFixed(1)}%`);
                }
            }
           
            const battery = currentData.map(d => d.battVolt).filter(b => b !== null && !isNaN(b));
            if (battery.length > 0) {
                const latestBatt = battery[battery.length - 1];
                const avgBatt = battery.reduce((a, b) => a + b, 0) / battery.length;
                insights.push(`Battery status: Current ${latestBatt.toFixed(2)}V, Average ${avgBatt.toFixed(2)}V`);
            }
           
            return insights;
        }
        function generateTrendInsights(config) {
            const insights = [];
           
            config.primaryFields.forEach(field => {
                const values = currentData.map(d => d[field]).filter(v => v !== null && !isNaN(v));
                if (values.length > 10) {
                    const trend = calculateTrend(values);
                    const trendText = trend > 0.1 ? 'increasing' : trend < -0.1 ? 'decreasing' : 'stable';
                    insights.push(`${config.labels[field]} is ${trendText} (slope: ${trend.toFixed(4)})`);
                }
            });
           
            return insights;
        }
        function generateAnomalyInsights(config) {
            const insights = [];
           
            config.primaryFields.forEach(field => {
                const values = currentData.map(d => d[field]).filter(v => v !== null && !isNaN(v));
                if (values.length > 10) {
                    const anomalies = detectAnomalies(values);
                    if (anomalies.length > 0) {
                        insights.push(`${config.labels[field]}: ${anomalies.length} anomalous readings detected`);
                    }
                }
            });
           
            return insights;
        }
        function generateForecastInsights(config) {
            const insights = [];
           
            config.primaryFields.forEach(field => {
                const values = currentData.map(d => d[field]).filter(v => v !== null && !isNaN(v));
                if (values.length > 20) {
                    const forecast = advancedForecast(values, 7);
                    const current = values[values.length - 1];
                    const change = ((forecast.linear - current) / current) * 100;
                    insights.push(`${config.labels[field]} 7-day linear forecast: ${forecast.linear.toFixed(2)} ${config.units[field]} (${change > 0 ? '+' : ''}${change.toFixed(1)}% change)`);
                }
            });
           
            return insights;
        }
        function displayInsights(insights) {
            const insightsHTML = `
                <div class="insights-section">
                    <h3>Data Insights</h3>
                    ${insights.map(insight => `<div class="insight-item">${insight}</div>`).join('')}
                </div>
            `;
           
            document.getElementById('insightsSection').innerHTML = insightsHTML;
        }
        async function generateAdvancedForecast() {
            if (currentData.length < 20) {
                showStatus('Need at least 20 data points for forecasting', 'error');
                return;
            }
           
            const dataSource = document.getElementById('dataSource').value;
            if (dataSource !== 'server') {
                showStatus('Advanced forecasting is only available via local server', 'error');
                return;
            }
           
            const serverUrl = document.getElementById('serverUrl').value.trim();
           
            showStatus('Generating advanced forecasts from server...', 'loading');
           
            try {
                const response = await fetch(`${serverUrl}/forecast/${currentDevice.type}/${currentDevice.DeviceEUI}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        horizon_days: 7,
                        model_type: 'prophet'
                    })
                });
               
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
               
                const forecastData = await response.json();
               
                displayServerForecastResults(forecastData);
                createForecastChartFromServer(forecastData);
                showStatus('Advanced forecasts generated successfully', 'success');
               
                if (forecastData.alerts.length > 0) {
                    showStatus(forecastData.alerts.join('<br>'), 'warning');
                }
               
            } catch (error) {
                showStatus(`Forecast generation failed: ${error.message}`, 'error');
                console.error('Forecast error:', error);
            }
        }
        function displayServerForecastResults(forecastData) {
            const config = deviceConfigs[currentDevice.type];
            const field = forecastData.forecast_field;
            const predictions = forecastData.forecast;
            const days = predictions.length;
           
            let forecastHTML = `
                <div class="forecast-section">
                    <h3>${days}-Day Advanced Forecast Results for ${config.labels[field]}</h3>
                    <p>Using Prophet model</p>
                    <div class="forecast-methods">
            `;
           
            predictions.forEach((pred, idx) => {
                forecastHTML += `
                    <div class="method-result">
                        <div class="method-name">Day ${idx + 1} (${new Date(pred.ds).toLocaleDateString()})</div>
                        <div class="method-value">${pred.yhat.toFixed(2)} ${config.units[field]}</div>
                        <div class="method-confidence">Range: ${pred.yhat_lower.toFixed(2)} - ${pred.yhat_upper.toFixed(2)}</div>
                    </div>
                `;
            });
           
            forecastHTML += '</div></div>';
            document.getElementById('forecastSection').innerHTML = forecastHTML;
        }
        function createForecastChartFromServer(forecastData) {
            const config = deviceConfigs[currentDevice.type];
            const field = forecastData.forecast_field;
            const predictions = forecastData.forecast;
           
            const chartContainer = document.createElement('div');
            chartContainer.className = 'forecast-chart-container';
            chartContainer.innerHTML = '<canvas id="forecastChart"></canvas>';
            document.getElementById('forecastSection').appendChild(chartContainer);
           
            const ctx = document.getElementById('forecastChart').getContext('2d');
           
            // Use recent historical for context
            const recentValues = currentData.slice(-30).map(d => ({
                x: new Date(d.timestamp),
                y: d[field]
            }));
           
            const forecastValues = predictions.map(pred => ({
                x: new Date(pred.ds),
                y: pred.yhat
            }));
           
            const lowerBounds = predictions.map(pred => ({
                x: new Date(pred.ds),
                y: pred.yhat_lower
            }));
           
            const upperBounds = predictions.map(pred => ({
                x: new Date(pred.ds),
                y: pred.yhat_upper
            }));
           
            const datasets = [
                {
                    label: `Historical ${config.labels[field]}`,
                    data: recentValues,
                    borderColor: config.colors[field],
                    backgroundColor: config.colors[field] + '20',
                    fill: false,
                    pointRadius: 3,
                    borderWidth: 2
                },
                {
                    label: 'Forecast',
                    data: forecastValues,
                    borderColor: '#e74c3c',
                    backgroundColor: '#e74c3c10',
                    fill: false,
                    borderDash: [5, 5],
                    pointRadius: 4
                },
                {
                    label: 'Lower Bound',
                    data: lowerBounds,
                    borderColor: '#3498db',
                    backgroundColor: 'transparent',
                    borderDash: [3, 3],
                    pointRadius: 0
                },
                {
                    label: 'Upper Bound',
                    data: upperBounds,
                    borderColor: '#3498db',
                    backgroundColor: 'transparent',
                    borderDash: [3, 3],
                    pointRadius: 0
                }
            ];
           
            if (forecastChart) {
                forecastChart.destroy();
            }
           
            forecastChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    day: 'MMM dd',
                                    hour: 'MMM dd HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${config.labels[field]} (${config.units[field]})`
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `7-Day Forecast: ${config.labels[field]}`
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} ${config.units[field]}`;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        // Helper functions
        function getTimeSpan() {
            const firstRecord = new Date(currentData[0].timestamp);
            const lastRecord = new Date(currentData[currentData.length - 1].timestamp);
            const days = Math.ceil((lastRecord - firstRecord) / (1000 * 60 * 60 * 24));
            return { days, firstRecord, lastRecord };
        }
        function calculateDataQuality() {
            const expectedInterval = 3600000; // 1 hour in milliseconds
            let gaps = 0;
           
            for (let i = 1; i < Math.min(currentData.length, 1000); i++) {
                const timeDiff = new Date(currentData[i].timestamp) - new Date(currentData[i-1].timestamp);
                if (timeDiff > expectedInterval * 2) {
                    gaps++;
                }
            }
           
            return Math.max(0, (1 - gaps / (currentData.length / 100)) * 100);
        }
        function calculateTrend(values) {
            const n = values.length;
            const x = values.map((_, i) => i);
            const y = values;
           
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
           
            return (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        }
        function detectAnomalies(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const std = Math.sqrt(values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length);
            const threshold = 2 * std;
           
            return values.filter(val => Math.abs(val - mean) > threshold);
        }
        function calculateForecastConfidence(values) {
            const recent = values.slice(-20);
            const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
            const cv = Math.sqrt(variance) / Math.abs(mean);
           
            return Math.max(0.1, Math.min(0.95, 1 - cv));
        }
        function exportAnalysisResults() {
            if (currentData.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
           
            const config = deviceConfigs[currentDevice.type];
            const csvContent = convertToCSV(currentData, config);
            const filename = `${currentDevice.DevName.replace(/[^a-zA-Z0-9]/g, '_')}_analysis_${new Date().toISOString().split('T')[0]}.csv`;
           
            downloadFile(csvContent, filename, 'text/csv');
            showStatus(`Analysis exported as ${filename}`, 'success');
        }
        function convertToCSV(data, config) {
            const headers = ['timestamp', 'deviceEUI', ...config.primaryFields, ...config.secondaryFields];
            const csvRows = [headers.join(',')];
           
            data.forEach(row => {
                const values = headers.map(header => row[header] || '');
                csvRows.push(values.join(','));
            });
           
            return csvRows.join('\n');
        }
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }
        function showDeviceInfo(device) {
            const infoHTML = `
                <div class="device-info">
                    <h3>${device.DevName}</h3>
                    <div class="device-details">
                        <div class="detail-item">
                            <div class="detail-label">Location</div>
                            <div class="detail-value">${device.SiteName}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Coordinates</div>
                            <div class="detail-value">${device.Lat}, ${device.Lon}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Device Type</div>
                            <div class="detail-value">${device.type}</div>
                        </div>
                        ${device.EmptyDistance ? `
                        <div class="detail-item">
                            <div class="detail-label">Empty Distance</div>
                            <div class="detail-value">${device.EmptyDistance}mm</div>
                        </div>` : ''}
                        <div class="detail-item">
                            <div class="detail-label">Device EUI</div>
                            <div class="detail-value">${device.DeviceEUI}</div>
                        </div>
                    </div>
                </div>
            `;
           
            document.getElementById('deviceInfo').innerHTML = infoHTML;
        }
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            const icon = type === 'loading' ? '<span class="spinner"></span>' :
                        type === 'success' ? '✅' :
                        type === 'error' ? '❌' :
                        type === 'warning' ? '⚠️' : 'ℹ️';
           
            statusDiv.innerHTML = `<div class="status ${type}">${icon} ${message}</div>`;
        }
        function showProgress(message, percent) {
            const progressContainer = document.getElementById('progressContainer');
            progressContainer.style.display = 'block';
            progressContainer.innerHTML = `
                <h4>Data Collection Progress</h4>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${percent}%"></div>
                </div>
                <p>${message}</p>
            `;
        }
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        // Advanced Forecasting Functions (kept for compatibility, but server is primary)
        function advancedForecast(values, days) {
            try {
                const recent = values.slice(-Math.min(100, values.length));
                const n = recent.length;
               
                if (n < 10) {
                    throw new Error('Insufficient data for forecasting');
                }
               
                const linearForecast = linearRegressionForecast(recent, days);
                const movingAvgForecast = movingAverageForecast(recent, days, Math.min(14, n));
                const expSmoothingForecast = exponentialSmoothingForecast(recent, days);
                const seasonalForecast = seasonalForecast(recent, days);
               
                return {
                    linear: isFinite(linearForecast) ? linearForecast : recent[n-1],
                    movingAverage: isFinite(movingAvgForecast) ? movingAvgForecast : recent[n-1],
                    exponentialSmoothing: isFinite(expSmoothingForecast) ? expSmoothingForecast : recent[n-1],
                    seasonal: isFinite(seasonalForecast) ? seasonalForecast : recent[n-1]
                };
            } catch (error) {
                console.warn('Forecasting error:', error);
                const lastValue = values[values.length - 1];
                return {
                    linear: lastValue,
                    movingAverage: lastValue,
                    exponentialSmoothing: lastValue,
                    seasonal: lastValue
                };
            }
        }
        function linearRegressionForecast(values, days) {
            const n = values.length;
            const x = values.map((_, i) => i);
            const y = values;
           
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
           
            const denominator = (n * sumXX - sumX * sumX);
            if (denominator === 0) return values[n-1];
           
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
           
            const forecast = slope * (n + days - 1) + intercept;
            return isFinite(forecast) ? forecast : values[n-1];
        }
        function movingAverageForecast(values, days, window) {
            const recent = values.slice(-window);
            const sum = recent.reduce((a, b) => a + b, 0);
            const avg = sum / recent.length;
            return isFinite(avg) ? avg : values[values.length - 1];
        }
        function exponentialSmoothingForecast(values, days) {
            const alpha = 0.3; // smoothing parameter
            let forecast = values[0];
           
            for (let i = 1; i < values.length; i++) {
                forecast = alpha * values[i] + (1 - alpha) * forecast;
                if (!isFinite(forecast)) {
                    forecast = values[i];
                }
            }
           
            return isFinite(forecast) ? forecast : values[values.length - 1];
        }
        function seasonalForecast(values, days) {
            try {
                const seasonLength = Math.min(24, Math.floor(values.length / 4));
                if (values.length < seasonLength * 2) {
                    return values[values.length - 1];
                }
               
                const lastSeason = values.slice(-seasonLength);
                const avgSeasonal = lastSeason.reduce((a, b) => a + b, 0) / lastSeason.length;
               
                return isFinite(avgSeasonal) ? avgSeasonal : values[values.length - 1];
            } catch (error) {
                return values[values.length - 1];
            }
        }
        // SEPA API functions
        async function getDeviceBounds(device) {
            const params = new URLSearchParams({ device: device.DeviceEUI });
            if (device.type === 'HydroRanger' || device.type === 'Theta') {
                params.append('type', device.type);
            }
           
            const response = await fetch(`${SEPA_BASE_BOUNDS}?${params}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        }
        async function fetchDeviceData(device, timestamp) {
            const params = new URLSearchParams({
                device: device.DeviceEUI,
                timestamp: timestamp
            });
            if (device.type === 'HydroRanger' || device.type === 'Theta') {
                params.append('type', device.type);
            }
           
            const response = await fetch(`${SEPA_BASE_FETCH}?${params}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        }
        // Parser functions (simplified versions from your Data_Parser_Examples.py)
        function parsePayload(deviceType, payload, emptyDistance = null) {
            try {
                if (deviceType === 'HydroRanger') {
                    return parseHydroRangerPayload(payload, emptyDistance ? parseInt(emptyDistance) : null);
                } else if (deviceType === 'Echo') {
                    return parseEchoData(payload, emptyDistance ? parseInt(emptyDistance) : null);
                } else if (deviceType === 'Droplet') {
                    return parseDropletData(payload);
                } else if (deviceType === 'Hygro') {
                    return parseHygroData(payload);
                } else if (deviceType === 'Theta') {
                    return parseThetaData(payload);
                }
            } catch (error) {
                console.warn('Parse error:', error);
                return null;
            }
        }
        function parseHydroRangerPayload(payload, emptyDist) {
            const bytes = hexToBytes(payload);
            if (bytes.length < 13) return null;
           
            const view = new DataView(bytes.buffer);
            const sensors = view.getInt8(0);
            const avg = view.getInt16(1, false);
            const min = view.getInt16(3, false);
            const max = view.getInt16(5, false);
            const temp = view.getInt16(7, false);
            const humid = view.getInt16(9, false);
           
            const levelAvg = emptyDist ? emptyDist - avg : avg;
            const levelMin = emptyDist ? emptyDist - max : min;
            const levelMax = emptyDist ? emptyDist - min : max;
            const airTemp = temp !== -777 ? temp / 100 : null;
            const airHumid = humid !== -777 ? humid / 100 : null;
           
            return [sensors, levelAvg, levelMin, levelMax, airTemp, airHumid];
        }
        function parseEchoData(payload, emptyDist) {
            const bytes = hexToBytes(payload);
            if (bytes.length < 10) return null;
           
            const view = new DataView(bytes.buffer);
            const dist = view.getInt16(0, false);
            const temp = view.getInt16(2, false);
            const batt = view.getInt16(4, false);
            const waterTemp = view.getInt16(6, false);
            const status = view.getInt16(8, false);
           
            const level = emptyDist ? emptyDist - dist : dist;
           
            return [level, temp / 100.0, Math.round((batt / 1000.0) * 100) / 100, waterTemp / 100.0, status];
        }
        function parseDropletData(payload) {
            const bytes = hexToBytes(payload);
            if (bytes.length < 16) return null;
           
            const view = new DataView(bytes.buffer);
            const temp = view.getInt16(0, false);
            const press = view.getInt32(2, false);
            const humid = view.getInt16(6, false);
            const batt = view.getInt16(8, false);
            const rtcTemp = view.getInt16(10, false);
            const rain = view.getInt16(12, false);
            const status = view.getInt16(14, false);
           
            return [
                temp / 100.0,
                press / 100.0,
                humid / 100.0,
                Math.round((batt / 10.0) * 100) / 100,
                rtcTemp / 100.0,
                Math.round((rain * 0.42) * 100) / 100,
                status
            ];
        }
        function parseHygroData(payload) {
            const bytes = hexToBytes(payload);
            if (bytes.length < 14) return null;
           
            const view = new DataView(bytes.buffer);
            const vwc = view.getUint16(0, false);
            const soilTemp = view.getUint16(2, false);
            const ec = view.getInt16(4, false);
            const airTemp = view.getUint16(6, false);
            const humid = view.getUint16(8, false);
            const batt = view.getUint16(10, false);
            const status = view.getUint16(12, false);
           
            const rawVWC = vwc / 10.0;
            const calcVWC = Math.round(((((3.879 / 10000) * rawVWC) - 0.6956) * 100) * 100) / 100;
           
            return [
                calcVWC,
                Math.round((soilTemp / 100.0) * 100) / 100,
                parseFloat(ec),
                airTemp / 100.0,
                humid / 100.0,
                Math.round((batt / 1000.0) * 100) / 100,
                status
            ];
        }
        function parseThetaData(payload) {
            const asciiStr = hexToAscii(payload);
            const matches = asciiStr.match(/[+-][\d.]+/g);
            if (!matches || matches.length < 3) return null;
           
            const rawVWC = parseFloat(matches[0]);
            const ts = parseFloat(matches[1]);
            const ecs = parseFloat(matches[2]);
           
            const calcVWC = Math.round(((((3.879 / 10000) * rawVWC) - 0.6956) * 100) * 100) / 100;
           
            return [calcVWC, ts, ecs];
        }
        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }
        function hexToAscii(hex) {
            let ascii = '';
            for (let i = 0; i < hex.length; i += 2) {
                ascii += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return ascii;
        }
    </script>
</body>
</html>